# --- Load local.settings.json File ---

$settingsFile = "local.settings.json"
if (Test-Path $settingsFile) {
    Write-Host "‚öôÔ∏è Loading environment variables from local.settings.json file..."
    $jsonContent = Get-Content $settingsFile -Raw | ConvertFrom-Json
    $jsonContent.Values.PSObject.Properties | ForEach-Object {
        [Environment]::SetEnvironmentVariable($_.Name, $_.Value, "Process")
    }
} else {
    Write-Warning "‚ö†Ô∏è local.settings.json file not found. Assuming variables are already set in the environment."
}

# --- Environment Setup and Configuration ---

Write-Host "‚öôÔ∏è Initializing GitHub-based email automation script..."

# Load all required settings from environment variables
$settings = @{
    SendGridKey       = $env:SENDGRID_API_KEY
    EmailFrom         = $env:EMAIL_FROM  
    ClientEmail       = "john@datan8.com"  # Test data
    ClientEmailTitle  = "Bug in website"  # Test data
    ClientEmailBody   = "Hi when I refresh the contact page it gives me a 404"  # Test data
    GhlApiKey         = $env:GHL_API_KEY
    GhlLocationId     = $env:GHL_LOCATION_ID
    GhlDomain         = $env:GHL_DOMAIN
    OpenAIKey         = $env:OPENAI_API_KEY
    OpenAIModel       = $env:OPENAI_MODEL
    GitHubToken       = $env:GITHUB_TOKEN
    GitHubOrg         = $env:GITHUB_ORG
    GitHubTemplateRepo = $env:GITHUB_TEMPLATE_REPO
    ApprovalBaseUrl   = $env:APPROVAL_BASE_URL
    # Amazon Q Business Configuration
    AmazonQApplicationId = $env:AMAZON_Q_APPLICATION_ID
    AmazonQApplicationName = $env:AMAZON_Q_APPLICATION_NAME
    AmazonQDeployedUrl = $env:AMAZON_Q_DEPLOYED_URL
    AmazonQServiceRoleArn = $env:AMAZON_Q_SERVICE_ROLE_ARN
    AmazonQWebExperienceRoleArn = $env:AMAZON_Q_WEB_EXPERIENCE_ROLE_ARN
    AwsAccountId      = $env:AWS_ACCOUNT_ID
    AwsRegion         = $env:AWS_REGION
}

# Validate that all settings are present
$missingSettings = $settings.Keys | Where-Object { [string]::IsNullOrEmpty($settings[$_]) }
if ($missingSettings) {
    throw "Missing required environment variables: $($missingSettings -join ', ')"
}

# API Headers
$ghlHeaders = @{ "Authorization" = "Bearer $($settings.GhlApiKey)"; "Content-Type" = "application/json" }
$openAIHeaders = @{ "Authorization" = "Bearer $($settings.OpenAIKey)"; "Content-Type" = "application/json" }
$sendGridHeaders = @{ "Authorization" = "Bearer $($settings.SendGridKey)"; "Content-Type" = "application/json" }
$githubHeaders = @{ 
    "Authorization" = "Bearer $($settings.GitHubToken)"
    "Accept" = "application/vnd.github+json"
    "User-Agent" = "EmailAutomation/1.0"
}

# --- Helper Functions ---

function Send-ConfirmationEmail {
    param([string]$clientEmail, [string]$contentSummary, [string]$approveLink, [string]$rejectLink, [string]$approvalToken)
    
    Write-Host "üìß Sending confirmation email to client: $clientEmail"
    
    $htmlContent = @"
<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #007bff; color: white; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
        .content { background-color: #f8f9fa; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
        .buttons { margin: 20px 0; text-align: center; }
        .button { display: inline-block; padding: 15px 30px; color: white; text-decoration: none; border-radius: 5px; margin: 0 10px; font-weight: bold; }
        .approve { background-color: #28a745; }
        .reject { background-color: #dc3545; }
        .footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; font-size: 12px; color: #666; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h2>üîç Confirm Your Website Change Request</h2>
        </div>
        <div class="content">
            <p>Dear Client,</p>
            <p>We've analyzed your email and interpreted it as the following:</p>
            <p><strong>Summary:</strong> $contentSummary</p>
            
            <p>To proceed with this change, please click one of the links below:</p>
            
            <div class="buttons">
                <a href="$approveLink" class="button approve">[APPROVE ‚úÖ]</a>
                <a href="$rejectLink" class="button reject">[REJECT ‚ùå]</a>
            </div>
            
            <p><strong>Approval Token:</strong> $approvalToken</p>
            
            <p>If you have any questions or need to provide additional details, please reply to this email.</p>
            
            <p>Best regards,<br>Your Website Automation Team</p>
        </div>
        <div class="footer">
            <p>This email was automatically generated by the email automation system.</p>
            <p>Generated on: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')</p>
        </div>
    </div>
</body>
</html>
"@

    $textContent = @"
Confirm Your Website Change Request

Dear Client,

We've analyzed your email and interpreted it as the following:
Summary: $contentSummary

To proceed with this change, please click one of the links below:

[APPROVE ‚úÖ] $approveLink

[REJECT ‚ùå] $rejectLink

Approval Token: $approvalToken

If you have any questions or need to provide additional details, please reply to this email.

Best regards,
Your Website Automation Team

---
This email was automatically generated by the email automation system.
Generated on: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
"@

    $emailBody = @{
        personalizations = @(@{ to = @(@{ email = $clientEmail }) })
        from             = @{ email = $settings.EmailFrom }
        subject          = "Confirm Your Website Change Request - Token: $approvalToken"
        content          = @(
            @{ type = "text/plain"; value = $textContent },
            @{ type = "text/html"; value = $htmlContent }
        )
        tracking_settings = @{
            click_tracking = @{ enable = $false }
            open_tracking = @{ enable = $false }
        }
    } | ConvertTo-Json -Depth 10

    try {
        Invoke-RestMethod -Uri "https://api.sendgrid.com/v3/mail/send" -Method Post -Headers $sendGridHeaders -Body $emailBody -ErrorAction Stop
        Write-Host "‚úÖ Confirmation email sent successfully."
        return $true
    }
    catch {
        Write-Warning "‚ùå Failed to send confirmation email: $($_.Exception.Message)"
        return $false
    }
}

function Classify-EmailContent {
    param($headers, [string]$emailContent)
    Write-Host "ü§ñ Classifying email content with OpenAI..."
    
    $prompt = @"
Analyze this email content and determine if it's a bug report or feature request for a website change. 

Rules:
- If it describes something broken, not working, or an error: respond with "bug"
- If it requests new functionality or changes: respond with "feature"  
- If it's neither: respond with "neither"

For bug or feature, provide a clear, concise summary in this format:
[TYPE]: [SUMMARY]

Examples:
- bug: Contact page returns 404 error when refreshed
- feature: Add dark mode toggle to navigation menu
- neither

Email content: "$emailContent"
"@

    $body = @{
        model      = $settings.OpenAIModel
        messages   = @(@{ role = "user"; content = $prompt })
        max_tokens = 200
        temperature = 0.1
    } | ConvertTo-Json -Depth 5

    try {
        $response = Invoke-RestMethod -Uri "https://api.openai.com/v1/chat/completions" -Method Post -Headers $headers -Body $body -ErrorAction Stop
        $classification = $response.choices[0].message.content.Trim()
        Write-Host "   ‚úÖ OpenAI classification: $classification"
        return $classification
    }
    catch {
        Write-Warning "   ‚ùå OpenAI classification failed: $($_.Exception.Message)"
        return "neither"
    }
}

function Find-ClientAccount {
    param($headers, [string]$clientEmail)
    Write-Host "üë§ Finding client account for email: $clientEmail"
    
    $encodedEmail = [uri]::EscapeDataString($clientEmail)
    try {
        $contactResult = Invoke-RestMethod -Uri "https://rest.gohighlevel.com/v1/contacts/lookup?email=$encodedEmail" -Method Get -Headers $headers
        if ($contactResult.contacts -and $contactResult.contacts.Count -gt 0) {
            $contact = $contactResult.contacts[0]
            $accountId = $contact.id
            Write-Host "   ‚úÖ Found account ID: $accountId"
            
            # Try to find website URL in contact custom fields
            $websiteUrl = $contact.customFields | Where-Object { $_.name -like "*website*" -or $_.name -like "*url*" } | Select-Object -First 1 -ExpandProperty value
            if (-not $websiteUrl) {
                $websiteUrl = $contact.website
            }
            
            return @{
                AccountId = $accountId
                WebsiteUrl = $websiteUrl
                Contact = $contact
            }
        } else {
            Write-Host "   ‚ö†Ô∏è No account found."
            return $null
        }
    }
    catch {
        Write-Warning "   ‚ùå Failed to find account: $($_.Exception.Message)"
        return $null
    }
}

function Create-GitHubIssue {
    param($headers, [string]$type, [string]$title, [string]$description, [string]$repository, [string]$websiteUrl, [string]$accountId, [string]$approvalToken)
    Write-Host "üìã Creating GitHub Issue: $title"
    
    # Amazon Q specific labels for automated development
    $labels = @("amazon-q", "client-request", "auto-generated")
    if ($type.ToLower() -eq "bug") {
        $labels += "bug"
    } elseif ($type.ToLower() -eq "feature") {
        $labels += "enhancement"
    }
    
    # Create detailed issue body with AI instructions
    $issueBody = @"
## $type Report

**Description:** $description

**Website:** $websiteUrl
**Account ID:** $accountId
**Approval Token:** $approvalToken
**Status:** Pending Client Approval

## Amazon Q Business Integration
**Application:** $($settings.AmazonQApplicationName)
**Application ID:** $($settings.AmazonQApplicationId)
**AWS Account:** $($settings.AwsAccountId)
**Region:** $($settings.AwsRegion)

## AI Instructions for @amazon-q
$( if ($type.ToLower() -eq "bug") { 
    "Please analyze this bug report and implement a fix. Steps to follow:
1. Identify the root cause of the issue
2. Review the website code structure
3. Implement the necessary fixes
4. Ensure the solution is tested and working
5. Create a pull request with your changes" 
} else { 
    "Please implement this feature request. Steps to follow:
1. Analyze the requirements carefully
2. Design the feature following best practices
3. Implement the functionality with clean, maintainable code
4. Ensure mobile responsiveness and accessibility
5. Test thoroughly and create a pull request" 
} )

## Technical Requirements
- Use modern web technologies (HTML5, CSS3, JavaScript)
- Ensure mobile responsiveness and accessibility
- Follow existing code patterns and conventions
- Include appropriate error handling
- Test thoroughly before submitting

## Next Steps
- [ ] Client approval received
- [ ] @amazon-q assigns and analyzes issue
- [ ] Code analysis completed  
- [ ] Solution implemented
- [ ] Pull request created
- [ ] Testing completed
- [ ] Deployed to production

---
*This issue was created automatically from a client email request.*
*Generated on: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')*
*Amazon Q Application: $($settings.AmazonQApplicationName)*
"@

    $body = @{
        title  = $title
        body   = $issueBody
        labels = $labels
        assignees = @()  # Will be assigned after approval
    } | ConvertTo-Json -Depth 5

    try {
        $url = "https://api.github.com/repos/$($settings.GitHubOrg)/$repository/issues"
        Write-Host "   üîó Creating issue at: $url"
        
        $issue = Invoke-RestMethod -Uri $url -Method Post -Headers $headers -Body $body -ErrorAction Stop
        Write-Host "   ‚úÖ Created GitHub issue #$($issue.number): $($issue.html_url)"
        
        return @{
            Number = $issue.number
            Url = $issue.html_url
            Id = $issue.id
        }
    }
    catch {
        Write-Warning "   ‚ùå Failed to create GitHub issue: $($_.Exception.Message)"
        if ($_.Exception.Response) {
            $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
            $errorBody = $reader.ReadToEnd()
            Write-Host "Error details: $errorBody" -ForegroundColor Red
        }
        return $null
    }
}

function Update-GitHubIssue {
    param($headers, [string]$repository, [int]$issueNumber, [string]$status, [string]$assignee = $null)
    Write-Host "ÔøΩ Updating GitHub Issue #$issueNumber to status: $status"
    
    $body = @{}
    
    # Update labels based on status
    if ($status -eq "approved") {
        $body.labels = @("bot", "approved", "ready-for-ai")
        if ($assignee) {
            $body.assignees = @($assignee)
        }
        
        # Add approval comment with Amazon Q mention
        $commentBody = @{
            body = @"
‚úÖ **Client Approval Received**

@amazon-q please help with this issue.

## Project Details
**Application:** $($settings.AmazonQApplicationName)
**Website URL:** Available in issue description
**Priority:** Standard client request

## Instructions
This issue has been approved by the client and is ready for AI implementation. Please:

1. **Analyze** the issue description carefully
2. **Review** the existing website structure if available
3. **Implement** the requested changes following best practices
4. **Test** your implementation thoroughly
5. **Create** a pull request with your solution

## Expected Deliverables
- Clean, well-documented code
- Mobile-responsive implementation
- Cross-browser compatibility
- Proper error handling
- Clear commit messages

Please proceed with the implementation and link your pull request back to this issue.

---
*Approval processed automatically at $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')*
*Amazon Q Application: $($settings.AmazonQApplicationName)*
"@
        } | ConvertTo-Json
        
        try {
            $commentUrl = "https://api.github.com/repos/$($settings.GitHubOrg)/$repository/issues/$issueNumber/comments"
            Invoke-RestMethod -Uri $commentUrl -Method Post -Headers $headers -Body $commentBody -ErrorAction Stop
            Write-Host "   ‚úÖ Added approval comment"
        }
        catch {
            Write-Warning "   ‚ö†Ô∏è Failed to add comment: $($_.Exception.Message)"
        }
    }
    elseif ($status -eq "rejected") {
        $body.labels = @("bot", "rejected", "needs-clarification")
        $body.state = "closed"
    }
    
    if ($body.Count -gt 0) {
        try {
            $url = "https://api.github.com/repos/$($settings.GitHubOrg)/$repository/issues/$issueNumber"
            $updateBody = $body | ConvertTo-Json -Depth 5
            Invoke-RestMethod -Uri $url -Method Patch -Headers $headers -Body $updateBody -ErrorAction Stop
            Write-Host "   ‚úÖ Updated GitHub issue #$issueNumber"
            return $true
        }
        catch {
            Write-Warning "   ‚ùå Failed to update GitHub issue: $($_.Exception.Message)"
            return $false
        }
    }
    
    return $true
}

function Handle-ClientApproval {
    param([string]$approvalToken, [string]$response, [string]$repository)
    Write-Host "üéØ Processing client approval for token: $approvalToken"
    
    # In a real implementation, you'd store approval tokens with associated issue numbers
    # For now, we'll simulate finding the issue by searching for the token in issue bodies
    
    try {
        $searchUrl = "https://api.github.com/search/issues?q=repo:$($settings.GitHubOrg)/$repository+$approvalToken+in:body+state:open"
        $searchResult = Invoke-RestMethod -Uri $searchUrl -Method Get -Headers $githubHeaders -ErrorAction Stop
        
        if ($searchResult.total_count -gt 0) {
            $issue = $searchResult.items[0]
            $issueNumber = $issue.number
            
            if ($response.ToLower() -eq "approve") {
                $success = Update-GitHubIssue -headers $githubHeaders -repository $repository -issueNumber $issueNumber -status "approved"
                if ($success) {
                    Write-Host "   ‚úÖ Issue #$issueNumber approved and ready for AI implementation"
                    return $true
                }
            }
            elseif ($response.ToLower() -eq "reject") {
                $success = Update-GitHubIssue -headers $githubHeaders -repository $repository -issueNumber $issueNumber -status "rejected"
                if ($success) {
                    Write-Host "   ‚úÖ Issue #$issueNumber rejected and closed"
                    return $true
                }
            }
        } else {
            Write-Warning "   ‚ö†Ô∏è No issue found with approval token: $approvalToken"
        }
    }
    catch {
        Write-Warning "   ‚ùå Failed to process approval: $($_.Exception.Message)"
    }
    
    return $false
}

function Get-NewHighlevelCases {
    param($headers)
    Write-Host "üì• Fetching new email cases from Highlevel..."
    
    # Updated to filter for contacts with recent email activity or specific tags
    # This is a more targeted approach than pulling ALL contacts
    $url = "https://rest.gohighlevel.com/v1/contacts"
    $params = @{
        "locationId" = $settings.GhlLocationId
        "limit" = 50
        "query" = "email_request"  # Adjust based on how you tag email requests
    }
    
    $queryString = ($params.GetEnumerator() | ForEach-Object { "$($_.Key)=$([uri]::EscapeDataString($_.Value))" }) -join "&"
    $fullUrl = "$url?$queryString"
    
    Write-Host "üîó API URL: $fullUrl" -ForegroundColor Cyan
    
    try {
        $response = Invoke-WebRequest -Uri $fullUrl -Method Get -Headers $headers -UseBasicParsing
        Write-Host "‚úÖ Response Status: $($response.StatusCode)" -ForegroundColor Green
        
        $cases = $response.Content | ConvertFrom-Json
        
        # Filter for contacts that haven't been processed yet
        # Look for contacts with specific tags or custom fields indicating new email requests
        $newCases = @()
        if ($cases.contacts) {
            $newCases = $cases.contacts | Where-Object { 
                $_.tags -notcontains "processed" -and 
                ($_.tags -contains "email_request" -or $_.customFields | Where-Object { $_.name -eq "email_content" })
            }
        }
        
        Write-Host "ÔøΩ Found $($newCases.Count) new unprocessed email cases"
        return $newCases
    }
    catch {
        Write-Warning "‚ùå Failed to fetch cases: $($_.Exception.Message)"
        return @()
    }
}

function Get-ClientRepository {
    param([string]$accountId, [string]$websiteUrl)
    
    # Try to determine the repository based on account ID or website URL
    # This could be stored in a configuration file or database
    
    if ($websiteUrl) {
        # Extract domain from URL and use as repo name
        try {
            $uri = [Uri]$websiteUrl
            $domain = $uri.Host -replace "^www\.", ""
            $repoName = $domain -replace "\.", "-"
            Write-Host "   ÔøΩ Determined repository: $repoName from website: $websiteUrl"
            return $repoName
        }
        catch {
            Write-Warning "   ‚ö†Ô∏è Could not parse website URL: $websiteUrl"
        }
    }
    
    # Fallback to account-based naming
    $repoName = "client-$accountId"
    Write-Host "   ÔøΩ Using fallback repository: $repoName"
    return $repoName
}

function Generate-ApprovalToken {
    # Generate a unique token for tracking approvals
    $timestamp = Get-Date -Format "yyyyMMddHHmmss"
    $random = Get-Random -Minimum 1000 -Maximum 9999
    return "APPR-$timestamp-$random"
}

# --- Main Execution ---

try {
    Write-Host "‚ñ∂Ô∏è Starting GitHub-based email processing workflow..."

    # Check if we should force test mode
    $forceTestMode = $env:FORCE_TEST_MODE -eq "true" -or $settings.ForceTestMode -eq $true
    
    # Poll for new email cases
    $cases = @()
    if (-not $forceTestMode) {
        $cases = Get-NewHighlevelCases -headers $ghlHeaders
    }
    
    # Test mode: If no cases found or testing, use the hardcoded test data
    $useTestData = $false
    if ($cases.Count -eq 0 -or $forceTestMode) {
        if ($forceTestMode) {
            Write-Host "üß™ Force test mode enabled. Using test data..." -ForegroundColor Yellow
        } else {
            Write-Host "‚ö†Ô∏è No new email cases found from API. Using test data..." -ForegroundColor Yellow
        }
        $useTestData = $true
        
        # Create a test case object using the settings
        $cases = @(@{
            id = "test-case-001"
            email = $settings.ClientEmail
            customFields = @(@{ name = "email_content"; value = "$($settings.ClientEmailTitle): $($settings.ClientEmailBody)" })
            tags = @("email_request")
            firstName = "Test"
            lastName = "User"
            website = "https://example.com"
        })
    }

    Write-Host "üìä Processing $($cases.Count) email case(s)" -ForegroundColor Green

    $results = @()

    foreach ($case in $cases) {
        # Extract email content based on case structure
        if ($useTestData) {
            $emailContent = "$($settings.ClientEmailTitle): $($settings.ClientEmailBody)"
            $clientEmail = $settings.ClientEmail
        } else {
            $emailContent = ($case.customFields | Where-Object { $_.name -eq "email_content" }).value
            if (-not $emailContent) {
                $emailContent = $case.notes -or ""
            }
            $clientEmail = $case.email
        }

        # Skip if no email content to process
        if ([string]::IsNullOrWhiteSpace($emailContent)) {
            Write-Host "Skipping case $($case.id) - no email content found"
            continue
        }

        Write-Host "`nüìß Processing case: $($case.id)" -ForegroundColor Cyan
        Write-Host "   Email: $clientEmail"
        Write-Host "   Content: $($emailContent.Substring(0, [Math]::Min(100, $emailContent.Length)))..." -ForegroundColor Gray

        # Classify content using AI
        $classification = Classify-EmailContent -headers $openAIHeaders -emailContent $emailContent
        if ($classification -eq "neither") {
            Write-Host "   ‚è≠Ô∏è Skipping non-relevant case: $($case.id)"
            continue
        }

        # Parse classification
        $parts = $classification -split ": ", 2
        if ($parts.Count -lt 2) {
            Write-Host "   ‚ö†Ô∏è Invalid classification format: $classification"
            continue
        }
        
        $type = $parts[0].Trim()
        $summary = $parts[1].Trim()

        # Find client account and website
        $accountInfo = Find-ClientAccount -headers $ghlHeaders -clientEmail $clientEmail
        if (-not $accountInfo) {
            Write-Host "   ‚ö†Ô∏è No account found for case $($case.id). Skipping."
            continue
        }

        # Determine repository
        $repository = Get-ClientRepository -accountId $accountInfo.AccountId -websiteUrl $accountInfo.WebsiteUrl
        
        # Generate unique approval token
        $approvalToken = Generate-ApprovalToken
        
        # Create GitHub issue
        $issue = Create-GitHubIssue -headers $githubHeaders -type $type -title $summary -description $emailContent -repository $repository -websiteUrl $accountInfo.WebsiteUrl -accountId $accountInfo.AccountId -approvalToken $approvalToken
        
        if ($issue) {
            # Generate approval links
            $approveLink = "$($settings.ApprovalBaseUrl)/approve?token=$approvalToken&repo=$repository"
            $rejectLink = "$($settings.ApprovalBaseUrl)/reject?token=$approvalToken&repo=$repository"

            # Send confirmation email to client
            $emailSent = Send-ConfirmationEmail -clientEmail $clientEmail -contentSummary $summary -approveLink $approveLink -rejectLink $rejectLink -approvalToken $approvalToken

            if ($emailSent) {
                $results += @{
                    CaseId = $case.id
                    IssueNumber = $issue.Number
                    IssueUrl = $issue.Url
                    Type = $type
                    Summary = $summary
                    ApprovalToken = $approvalToken
                    Repository = $repository
                    Status = "Pending Approval"
                }
                
                Write-Host "   ‚úÖ Case $($case.id) processed successfully as $type"
                Write-Host "   üìã GitHub Issue: $($issue.Url)"
                Write-Host "   üé´ Approval Token: $approvalToken"
            }
        }
    }

    Write-Host "`nüéâ Processing completed!" -ForegroundColor Green
    Write-Host "üìä Summary:"
    Write-Host "   - Cases processed: $($results.Count)"
    Write-Host "   - GitHub issues created: $($results.Count)"
    Write-Host "   - Approval emails sent: $($results.Count)"
    
    if ($results.Count -gt 0) {
        Write-Host "`nüìã Created Issues:"
        foreach ($result in $results) {
            Write-Host "   ‚Ä¢ #$($result.IssueNumber) ($($result.Type)): $($result.Summary)" -ForegroundColor Cyan
            Write-Host "     Repository: $($result.Repository)" -ForegroundColor Gray
            Write-Host "     Token: $($result.ApprovalToken)" -ForegroundColor Gray
        }
    }
}
catch {
    Write-Error "‚ùå An error occurred: $($_.Exception.Message)"
    Write-Host "Stack trace:" -ForegroundColor Red
    Write-Host $_.Exception.StackTrace
}
